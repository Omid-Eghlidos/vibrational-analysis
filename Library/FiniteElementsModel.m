classdef FiniteElementsModel
    properties (Access = public)
        % Mesh properties
        mesh = struct('dimension', struct('x', 0, 'y', 0), 'nodes', [], 'connectivity', [], ...
                      'elements', struct('Nx', 0, 'Ny', 0, 'dx', 0, 'dy', 0), ...
                      'force', struct('r', [], 'F', zeros(1, 3)));
        % All the nodes and their coordinates 
        nodes = [];
        % Total nodes cartesian coordinates (X, Y, Z)
        X = []; Y = []; Z = [];
        % Total nodes' numbers (nnt) and their degrees of freedom (ut)
        nnt = []; ut = [];
        % Ground nodes' numbers (nng) and their degrees of freedom (ug)
        nng = []; ug = [];
        % Free nodes' numbers (nnf) and their degrees of freedom (uf)
        nnf = []; uf = [];
        % Complete matrices and vector of equation of motion (EoM: Ma + Cv + Kx = F)
        % and their separate partitions after applying boundary conditions
        % resulting in ground (g) and free (f) nodes
        % Mass matrix (M) and its partitions
        M = []; Mgg = []; Mgf = []; Mfg = []; Mff = [];
        % Stiffness matrix (K) and its partitions
        K = []; Kgg = []; Kgf = []; Kfg = []; Kff = [];
        % Rayleigh damping matrix (C) and its partitions
        C = []; Cgg = []; Cgf = []; Cfg = []; Cff = [];
        % Force vector (F) and its partitions
        F = []; Fg = []; Ff = [];
    end

    methods (Access = public)
        function [obj] = FiniteElementsModel(params)
            obj = readFiniteElementsModelParameters(obj);
            obj = obj.reconstructFiniteElementsMesh(params);
            obj = obj.separateGroundAndFreeNodes();
            obj = obj.applyBoundaryConditions(params);
        end
    end

    methods (Access = private)
        function [obj] = readFiniteElementsModelParameters(obj)
            % Read FE mesh and parameters from files generated by NASTRAN
            obj.nodes = load('nodes.mat');
            % All the nodes and ground nodes number
            obj.nnt = obj.nodes.coordinates(:,1);
            obj.nng = obj.nodes.ground;

            % Nodal cartesian coordinates
            obj.X = obj.nodes.coordinates(:,2);
            obj.Y = obj.nodes.coordinates(:,3);
            obj.Z = obj.nodes.coordinates(:,4);

            % Read unrestrained finite element mass matrix (M)
            obj.M = obj.nastranOutputReader('M.dat');
            % Read unrestrained finite element stiffness matrix (K)
            obj.K = obj.nastranOutputReader('K.dat');
        end 

        function [Matrix] = nastranOutputReader(obj, filename)
            % Read OUTPUT4 fromat files of mass (M) and stiffness (K) matrices generated by NASTRAN
            file = importdata(filename);
            data = file.data;
            header = sscanf(file.textdata{1}, '%d %d %d %d', [1, 4]);
            [cols, rows] = deal(header(1), header(2));
            matrix = zeros(rows, cols);

            for i = 1:length(data)-1
                nz_row_i = nonzeros(data(i,:))';
                if ~isempty(nz_row_i) && isequal(floor(nz_row_i), nz_row_i)
                    if i > 1
                        temp(isnan(temp)) = 0;
                        matrix(row:row+length(temp)-1, col) = temp;
                    end
                    [col, row] = deal(data(i,1), data(i,2));
                    temp = [];
                else
                    temp = [temp; data(i,:)'];
                end
            end
            Matrix = matrix;
        end

        function [obj] = reconstructFiniteElementsMesh(obj, params)
            % Reconstruct the mesh of the imported FE model for the QUAD elements
            fprintf('%s Reconstructing FEM mesh for NASTRAN CQUAD4 elements\n', repmat('-', 1, 6));
            % Sort nodes based on their x coordinates to find number elements
            mesh_nodes = sortrows(obj.nodes.coordinates(:,2:4), [1, 2, 3]);
            unique_x = unique(mesh_nodes(:,1));
            unique_y = unique(mesh_nodes(:,2));
            unique_z = unique(mesh_nodes(:,3));
            % Initialize the connectivity matrix
            connectivity = zeros((length(unique_x) - 1)*(length(unique_y) - 1), 4);
            element_index = 1;

            for i = 1:(length(unique_x) - 1)
                for j = 1:(length(unique_y) - 1)
                    % Find node indices for the current QUAD element
                    n1 = find(mesh_nodes(:,1) == unique_x(i) & mesh_nodes(:,2) == unique_y(j));
                    n2 = find(mesh_nodes(:,1) == unique_x(i+1) & mesh_nodes(:,2) == unique_y(j));
                    n3 = find(mesh_nodes(:,1) == unique_x(i+1) & mesh_nodes(:,2) == unique_y(j+1));
                    n4 = find(mesh_nodes(:,1) == unique_x(i) & mesh_nodes(:,2) == unique_y(j+1));
                    % Skip if any node is missing
                    if isempty(n1) || isempty(n2) || isempty(n3) || isempty(n4)
                        continue;
                    end
                    connectivity(element_index, :) = [n1, n2, n3, n4];
                    element_index = element_index + 1;
                end
            end
            
            % Store mesh properties
            % Nodal coordinates of the mesh
            obj.mesh.nodes = mesh_nodes;
            % Size of the mesh in x, y, and z directions
            obj.mesh.dimension.x = [min(unique_x), max(unique_x)];
            obj.mesh.dimension.y = [min(unique_y), max(unique_y)];
            obj.mesh.dimension.z = [min(unique_z), max(unique_z)];
            % Number and size of elements for NASTRAN CQUAD4 in x & y directions
            obj.mesh.elements.Nx = (length(unique_x) - 1);
            obj.mesh.elements.Ny = (length(unique_y) - 1);
            obj.mesh.elements.Ne = (length(unique_x) - 1) * (length(unique_y) - 1);
            % Size of each elements in x and y directions (dx, dy)
            obj.mesh.elements.dx = (max(unique_x) - min(unique_x)) / length(unique_x);
            obj.mesh.elements.dy = (max(unique_y) - min(unique_y)) / length(unique_y);
            % Remove any unused rows in the connectivity matrix (if exists)
            obj.mesh.connectivity = connectivity(1:element_index-1, :);
            % Find the nodal force location and direction
            obj.mesh.force.r = mesh_nodes(params.Fc(1), :);
            obj.mesh.force.F(params.Fc(2)) = params.Fc(3);
        end

        function [obj] = separateGroundAndFreeNodes(obj)
            % Separate and initialize node numbers, DoFs, coordinates for
            % boundary/ground (g) and free (f) nodes
            % DoFs (ut) of all the nodes
            obj.ut = reshape(repmat((obj.nnt(:) - 1) * 6, 1, 6)' + (1:6)', [], 1);
            % Ground nodes' DoFs (ug)
            obj.ug = reshape(repmat((obj.nng(:) - 1) * 6, 1, 6)' + (1:6)', [], 1);
            % Free nodes' number (nnf) and their DoFs (uf)
            obj.nnf = setdiff(obj.nnt, obj.nng);
            obj.uf = reshape(repmat((obj.nnf(:) - 1) * 6, 1, 6)' + (1:6)', [], 1);
        end

        function [obj] = applyBoundaryConditions(obj, params)
            % Apply boundary conditions and separate mass (M), stiffness (K), Reyleigh
            % damping (C) matrices and force vector (F) for fixed/ground and free nodes
            % Finding the mass matrices Mgg, Mgf, Mfg, Mff
            obj.Mgg = obj.M(obj.ug, obj.ug);
            obj.Mgf = obj.M(obj.ug, obj.uf);
            obj.Mfg = obj.M(obj.uf, obj.ug);
            obj.Mff = obj.M(obj.uf, obj.uf);
            % Finding stiffness matrices Kgg, Kgf, Kfg, Kff
            obj.Kgg = obj.K(obj.ug, obj.ug);
            obj.Kgf = obj.K(obj.ug, obj.uf);
            obj.Kfg = obj.K(obj.uf, obj.ug);
            obj.Kff = obj.K(obj.uf, obj.uf);
            % Defining the damping matrix C using Rayleigh damping
            obj.Cgg = params.alpha * obj.Mgg + params.beta * obj.Kgg;
            obj.Cgf = params.alpha * obj.Mgf + params.beta * obj.Kgf;
            obj.Cfg = params.alpha * obj.Mfg + params.beta * obj.Kfg;
            obj.Cff = params.alpha * obj.Mff + params.beta * obj.Kff;
            obj.C = [obj.Cgg, obj.Cgf; obj.Cfg, obj.Cff];
            % Finding forces of the grounded and free nodes
            obj.Fg = zeros(length(obj.ug), 1);
            obj.Ff = zeros(length(obj.uf), 1);
            obj.F = [obj.Fg; obj.Ff];
            obj.F((params.Fc(1) - 1) * 6 + params.Fc(2)) = params.Fc(3);
        end
    end
end
