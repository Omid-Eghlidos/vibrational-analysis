classdef FiniteElementsModel
    properties (Access = public)
        % Mesh properties
        mesh = struct('dimension', struct('x', 0, 'y', 0), 'nodes', [], 'connectivity', [], ...
                      'elements', struct('Nx', 0, 'Ny', 0, 'dx', 0, 'dy', 0), ...
                      'force', struct('r', [], 'F', zeros(1, 3)));
        % Total nodes cartesian coordinates (X, Y, Z)
        X = []; Y = []; Z = [];
        % Total nodes' numbers (nnt) and their degrees of freedom (ut)
        nnt = []; ut = [];
        % Ground nodes' numbers (nng) and their degrees of freedom (ug)
        nng = []; ug = [];
        % Free nodes' numbers (nnf) and their degrees of freedom (uf)
        nnf = []; uf = [];
        % Complete matrices and vector of equation of motion (EoM: Ma + Cv + Kx = F)
        % and their separate partitions after applying boundary conditions
        % resulting in ground (g) and free (f) nodes
        % Mass matrix (M) and its partitions
        M = []; Mgg = []; Mgf = []; Mfg = []; Mff = [];
        % Stiffness matrix (K) and its partitions
        K = []; Kgg = []; Kgf = []; Kfg = []; Kff = [];
        % Rayleigh damping matrix (C) and its partitions
        C = []; Cgg = []; Cgf = []; Cfg = []; Cff = [];
        % Force vector (F) and its partitions
        F = []; Fg = []; Ff = [];
    end

    methods (Access = public)
        function [obj] = FiniteElementsModel(params)
            % Reconstruct the FE mesh and its connectivity matrix
            obj = obj.reconstructMesh(params);
            % Initialize and separate nodes for boundary/ground and free nodes
            obj = obj.separateGroundAndFreeNodes(params);

            % Read FE mesh parameters from output4 format files generated by NASTRAN
            % Read unrestrained finite element mass matrix (M)
            obj.M = nastranOutputReader('M.dat');
            % Read unrestrained finite element stiffness matrix (K)
            obj.K = nastranOutputReader('K.dat');

            % Apply the boundary conditions and partition the matrices
            obj = obj.applyBoundaryConditions(params);
        end
    end

    methods (Access = private)
        function [obj] = reconstructMesh(obj, params)
            % Reconstruct the mesh of the imported FE model for the QUAD elements
            disp('------ Reconstructing FEM mesh for NASTRAN CQUAD4 elements');
            % Sort nodes based on their x coordinates to find number elements
            nodes = sortrows(params.nodes_coord(:,2:4), [1, 2, 3]);
            unique_x = unique(nodes(:,1));
            unique_y = unique(nodes(:,2));
            unique_z = unique(nodes(:,3));
            % Initialize the connectivity matrix
            connectivity = zeros((length(unique_x) - 1)*(length(unique_y) - 1), 4);
            element_index = 1;

            for i = 1:(length(unique_x) - 1)
                for j = 1:(length(unique_y) - 1)
                    % Find node indices for the current QUAD element
                    n1 = find(nodes(:,1) == unique_x(i) & nodes(:,2) == unique_y(j));
                    n2 = find(nodes(:,1) == unique_x(i+1) & nodes(:,2) == unique_y(j));
                    n3 = find(nodes(:,1) == unique_x(i+1) & nodes(:,2) == unique_y(j+1));
                    n4 = find(nodes(:,1) == unique_x(i) & nodes(:,2) == unique_y(j+1));
                    % Skip if any node is missing
                    if isempty(n1) || isempty(n2) || isempty(n3) || isempty(n4)
                        continue;
                    end
                    connectivity(element_index, :) = [n1, n2, n3, n4];
                    element_index = element_index + 1;
                end
            end
            
            % Store mesh properties
            % Nodal coordinates of the mesh
            obj.mesh.nodes = nodes;
            % Size of the mesh in x, y, and z directions
            obj.mesh.dimension.x = [min(unique_x), max(unique_x)];
            obj.mesh.dimension.y = [min(unique_y), max(unique_y)];
            obj.mesh.dimension.z = [min(unique_z), max(unique_z)];
            % Number and size of elements for NASTRAN CQUAD4 in x & y directions
            obj.mesh.elements.Nx = (length(unique_x) - 1);
            obj.mesh.elements.Ny = (length(unique_y) - 1);
            obj.mesh.elements.Ne = (length(unique_x) - 1) * (length(unique_y) - 1);
            % Size of each elements in x and y directions (dx, dy)
            obj.mesh.elements.dx = (max(unique_x) - min(unique_x)) / length(unique_x);
            obj.mesh.elements.dy = (max(unique_y) - min(unique_y)) / length(unique_y);
            % Remove any unused rows in the connectivity matrix (if exists)
            obj.mesh.connectivity = connectivity(1:element_index-1, :);
            % Find the nodal force location and direction
            obj.mesh.force.r = nodes(params.Fc(1), :);
            obj.mesh.force.F(params.Fc(2)) = params.Fc(3);
        end

        function [obj] = separateGroundAndFreeNodes(obj, params)
            % Separate and initialize node numbers, DoFs, coordinates for
            % boundary/ground (g) and free (f) nodes
            % All the nodes cartesian coordinates
            obj.X = params.nodes_coord(:,2);
            obj.Y = params.nodes_coord(:,3);
            obj.Z = params.nodes_coord(:,4);

            % Total nodes numbers (nnt) and their DoFs (ut)
            obj.nnt = params.nodes_coord(:,1);
            obj.ut = reshape(repmat((obj.nnt(:) - 1) * 6, 1, 6)' + (1:6)', [], 1);

            % Ground nodes' number (nng) and their DoFs (ug)
            obj.nng = params.ground_nodes;
            obj.ug = reshape(repmat((obj.nng(:) - 1) * 6, 1, 6)' + (1:6)', [], 1);

            % Free nodes' number (nnf) and their DoFs (uf)
            obj.nnf = setdiff(obj.nnt, obj.nng);
            obj.uf = reshape(repmat((obj.nnf(:) - 1) * 6, 1, 6)' + (1:6)', [], 1);
        end

        function [obj] = applyBoundaryConditions(obj, params)
            % Apply boundary conditions and separate mass (M), stiffness (K), Reyleigh
            % damping (C) matrices and force vector (F) for fixed/ground and free nodes
            disp('------ Applying boundary conditions');
            % Finding the mass matrices Mgg, Mgf, Mfg, Mff
            obj.Mgg = obj.M(obj.ug, obj.ug);
            obj.Mgf = obj.M(obj.ug, obj.uf);
            obj.Mfg = obj.M(obj.uf, obj.ug);
            obj.Mff = obj.M(obj.uf, obj.uf);
            % Finding stiffness matrices Kgg, Kgf, Kfg, Kff
            obj.Kgg = obj.K(obj.ug, obj.ug);
            obj.Kgf = obj.K(obj.ug, obj.uf);
            obj.Kfg = obj.K(obj.uf, obj.ug);
            obj.Kff = obj.K(obj.uf, obj.uf);
            % Defining the damping matrix C using Rayleigh damping
            obj.Cgg = params.alpha * obj.Mgg + params.beta * obj.Kgg;
            obj.Cgf = params.alpha * obj.Mgf + params.beta * obj.Kgf;
            obj.Cfg = params.alpha * obj.Mfg + params.beta * obj.Kfg;
            obj.Cff = params.alpha * obj.Mff + params.beta * obj.Kff;
            obj.C = [obj.Cgg, obj.Cgf; obj.Cfg, obj.Cff];
            % Finding forces of the grounded and free nodes
            obj.Fg = zeros(length(obj.ug), 1);
            obj.Ff = zeros(length(obj.uf), 1);
            obj.F = [obj.Fg; obj.Ff];
            obj.F((params.Fc(1) - 1) * 6 + params.Fc(2)) = params.Fc(3);
        end
    end
end
